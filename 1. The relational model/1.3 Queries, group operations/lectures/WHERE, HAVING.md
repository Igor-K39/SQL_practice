## Выборка данных по условию, групповые функции
В запросы с групповыми функциями можно включать условие отбора строк, которое в обычных запросах записывается после WHERE. В запросах с групповыми функциями вместо WHERE используется ключевое слово HAVING , которое размещается после оператора GROUP BY.

**Пример 1.** Найти минимальную и максимальную цену книг всех авторов, общая стоимость книг которых больше 5000.
```sql
SELECT author, MIN(price) AS Минимальная_цена, 
               MAX(price) AS Максимальная_цена
  FROM book
 GROUP BY author
HAVING SUM(price * amount) > 5000; 
```
```
Результат:
+------------------+------------------+-------------------+
| author           | Минимальная_цена | Максимальная_цена |
+------------------+------------------+-------------------+
| Достоевский Ф.М. | 460.00           | 799.01            |
| Есенин С.А.      | 650.00           | 650.00            |
+------------------+------------------+-------------------+
```

**Пример 2.** Найти минимальную и максимальную цену книг всех авторов, общая стоимость книг которых больше 5000. Результат вывести по убыванию минимальной цены.
```sql
SELECT author, MIN(price) AS Минимальная_цена, 
               MAX(price) AS Максимальная_цена
  FROM book
 GROUP BY author
HAVING SUM(price * amount) > 5000 
 ORDER BY Минимальная_цена DESC;
```
```
Результат:
+------------------+------------------+-------------------+
| author           | Минимальная_цена | Максимальная_цена |
+------------------+------------------+-------------------+
| Есенин С.А.      | 650.00           | 650.00            |
| Достоевский Ф.М. | 460.00           | 799.01            |
+------------------+------------------+-------------------+
```

WHERE и HAVING могут использоваться в одном запросе. При этом необходимо учитывать **порядок выполнения  SQL запроса на выборку на СЕРВЕРЕ**:
- FROM  
- WHERE  
- GROUP BY  
- HAVING  
- SELECT  
- ORDER BY  

Сначала определяется таблица, из которой выбираются данные (FROM), затем из этой таблицы отбираются записи в соответствии с условием  WHERE, выбранные данные агрегируются (GROUP BY),  из агрегированных записей выбираются те, которые удовлетворяют условию после HAVING. Потом формируются данные результирующей выборки, как это указано после SELECT (вычисляются выражения, присваиваются имена и пр.). Результирующая выборка сортируется, как указано после ORDER BY.

Важно! Порядок ВЫПОЛНЕНИЯ запросов - это не порядок ЗАПИСИ ключевых слов в запросе на выборку. Порядок записи (синтаксис запроса) остается таким же, как рассматривался ранее в курсе. Порядок ВЫПОЛНЕНИЯ  нужен для того, чтобы понять, почему, например, в WHERE нельзя использовать имена выражений из SELECT. Просто SELECT выполняется компилятором позже, чем WHERE, поэтому ему неизвестно, какое там выражение написано.

**Пример 3.** Вывести максимальную и минимальную цену книг каждого автора, кроме Есенина, количество экземпляров книг которого больше 10. 
```sql
SELECT author, MIN(price) AS Минимальная_цена,
               MAX(price) AS Максимальная_цена
  FROM book
 WHERE author <> 'Есенин С.А.'
 GROUP BY author
HAVING SUM(amount) > 10;
```
```
Результат:
+------------------+------------------+-------------------+
| author           | Минимальная_цена | Максимальная_цена |
+------------------+------------------+-------------------+
| Достоевский Ф.М. | 460.00           | 799.01            |
+------------------+------------------+-------------------+
```

Этот запрос будет работать, если его переписать следующим образом:
```sql
SELECT author, MIN(price) AS Минимальная_цена,
               MAX(price) AS Максимальная_цена
  FROM book
 GROUP BY author
HAVING SUM(amount) > 10 AND author <> 'Есенин С.А.';
```
Не смотря на то что результат будет одинаковым, так делать **НЕ РЕКОМЕНДУЕТСЯ!** 
Потому что такой запрос сначала выбирает всех авторов, потом выводит данные, рассчитывая минимальное и максимальное значение цены для каждого, и только после всего убирает Есенина. Можно убрать Есенина в данном случае раньше и не использовать ресурсы базы для расчета его минимального и максимального значения, как это сделано в первом варианте. На небольшой базе быстродействия не ощутить, но если выполнять такое на продуктивной, то второй вариант значительно проигрывает.